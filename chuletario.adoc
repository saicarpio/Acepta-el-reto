= CppHULETARIO
This is for Acetpa el Reto users to have a quick reference of C++ concepts and libraries.
:doctype: book

Compiler used: g++ -std=c++11

:toc:  

== Basics of C++

=== Data Types

=== Pointer and References

=== Structures

=== Classes and Objects

== Useful Libraries

I want the usefull functions here and the code examples in the Algorithms and Data Structures section. At least for the Data Structures ones.

===  #include <algorithm>
[source,cpp]
----
#include <algorithm>

struct Comparator {
    bool operator()(int a, int b) {
        return a < b; // Ascending order
    }
};

int main() {
    int arr[] = {5, 2, 8, 1, 9};
    int n = sizeof(arr)/sizeof(arr[0]);
    
    std::sort(arr, arr + n, Comparator());
    
    // Print sorted array
    for(int i = 0; i < n; i++) {
        std::cout << arr[i] << " ";
    }
    
    return 0;
}
----

=== #include <vector>
[source,cpp]
----
#include <vector>
int main() {
    std::vector<int> vec;
    
    // Adding elements
    vec.push_back(10);
    vec.push_back(20);
    vec.push_back(30);
    
    // Accessing elements
    for(size_t i = 0; i < vec.size(); i++) {
        std::cout << vec[i] << " ";
    }
    
    return 0;
}
----

=== #include <string>
[source,cpp]
----
#include <string>
int main() {
    std::string str = "Hello, World!";
    
    // Accessing characters
    for(size_t i = 0; i < str.length(); i++) {
        std::cout << str[i] << " ";
    }
    
    return 0;
}
----

=== #include <stack>

At some point, I will make this pretty, as I want it. For now, the stack and queue libraries are extensions of the ddeque library, or so I think. Their memory is managed dinamically, automatically deleted when leavind the scope. Maybe I should move this to the Algorithms and Data Structures section.

[source,cpp]
----
#include <stack>
int main() {
    std::stack<int> s;
    
    // Pushing elements
    s.push(10);
    s.push(20);
    s.push(30);
    
    // Popping elements
    while(!s.empty()) {
        std::cout << s.top() << " ";
        s.pop();
    }
    
    return 0;
}
----

=== #include <queue>
[source,cpp]
----
#include <queue>
int main() {
    std::queue<int> q;
    
    // Enqueuing elements
    q.push(10);
    q.push(20);
    q.push(30);
    
    // Dequeuing elements
    while(!q.empty()) {
        std::cout << q.front() << " ";
        q.pop();
    }
    
    return 0;
}
----

=== #include <deque>
[source,cpp]
----
#include <deque>
int main() {
    std::deque<int> dq;
    
    // Pushing elements
    dq.push_back(10);
    dq.push_front(20);
    dq.push_back(30);
    
    // Popping elements
    while(!dq.empty()) {
        std::cout << dq.front() << " ";
        dq.pop_front();
    }
    
    return 0;
}
----

=== #include <map>
[source,cpp]
----
#include <map>
int main() {
    std::map<std::string, int> myMap;
    
    // Inserting key-value pairs
    myMap["apple"] = 1;
    myMap["banana"] = 2;
    myMap["cherry"] = 3;
    
    // Accessing values
    for(const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    
    return 0;
}
----

== Algorithms and Data Structures

=== Linked List
Tis the basic Node structure
[source,cpp]
----
struct Node {
    int data;
    Node* next; // Singly linked list
    Node* prev;  // Doubly linked list (optional)
    Node(int val) : data(val), next(nullptr), prev(nullptr) {}
};
----

For comfy operations
[source,cpp]
----
class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void insert(int val) {
        Node* newNode = new Node(val);
        if (!head) {
            head = newNode;
        } else {
            Node* temp = head;
            while (temp->next) {
                temp = temp->next;
            }
            temp->next = newNode;
        }
    }
    
    void display() {
        Node* temp = head;
        while (temp) {
            std::cout << temp->data << " -> ";
            temp = temp->next;
        }
        std::cout << "nullptr" << std::endl;
    }
};
int main() {
    LinkedList list;
    list.insert(10);
    list.insert(20);
    list.insert(30);
    list.display(); // Output: 10 -> 20 -> 30 -> nullptr
    return 0;
}
----

=== Math Utilities and Number Theory

Aparece mucho lo del triángulo de Pascal, combinatoria, etc.
Los problemas 335 y 433 eran del palo, calcular el tamaño de los niveles o cuantos niveles para tantos elementos.
La suma de Gauss me ha resultado útil para esto.

Otra movida es lo de los número primos, cribas, factorización, gcd, lcm, etc.
Nedesito un algoritmo rápido para calcular gcd y lcm.
El problema 226 parecía de fracciones pero haciendo magia negra se transformaba en factorización de números.

Como en los problemas NP, que tenía que encontrar la transformada de un problema a otro.

== References

